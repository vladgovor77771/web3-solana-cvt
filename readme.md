# Отчет по проекту

## Специфика СК solana

Смарт-контракты пишутся на rust/c/c++ и называются программами в терминологии solana. В solana немного непривычный метод хранения информации, принято хранить инфу в самом аккаунте пользователя, например, баланс пользователя по определенному токену хранится в data этого account. Таким образом, при инициализации кошелька, пользователь платит за хранение, так же работает, например, с nft. Что это значит для контрактов? В некоторых случаях контрактам вообще не нужен никакой storage, например SPL не хранит в себе ничего, кроме системных штук, типа owner account.

## Certora Prover

Certora Prover - облачное решение для аудита смарт-контрактов Ethereum и solana. Есть несколько платных версий и одна бесплатная, отличаются количеством проверок (в месяц).

### Возможности и функционал

Core концепт заключается в формализации и CVL Rules. С помощью таких правил можно реализовать формальную верификацию (проверку валидности) алгоритма, [пример](https://docs.certora.com/projects/tutorials/en/latest/lesson1_prerequisites/formal_verification.html). То, что описано в примере, похоже на применение такого языка как Prolog - логический язык программирования, внутри него используются solving trees, нечто похожее используется и в certora prover - SMT solver. С помощью CVL Rules также можно (и это основной юз кейс) писать тесты функций смарт-контрактов. SMT solver пытается найти контрпример, такой что не будет удовлетворять assert'ам в спеке.

### Certora Prover & Solana

В solana контракты компилируются в SBF - solana binary format, при этом сам код контракта может быть написан как на rust, так и на с и с++. Разработчики Certora представили новый инструмент для анализа смарт-контрактов solana, который анализирует как раз SBF. Этот инструмент декомпилирует SBF в IR формат, и далее уже проводит анализ. Также он использует абстрактную интерпретацию кода в некоторых ситуациях.

Что касается библиотеки для раста: с помощью нее можно писать спеки для тестирования смарт-контрактов для solana. Спеки выглядят как обычные функции на расте, внутри которых вызываются методы смартконтракта. В либе есть недетерменированные врапперы для solana типов, таких как AccountInfo, Pubkey, а также обычных примитивных.

### Установка

Зависимости:

- Python >=3.8.16
- JDK >= 11
- Solc >= 0.5

Solc по идее нужен только для аудита ethereum смарт-контрактов, для solana он вряд ли нужен, но в инструкции пишут, что обязательно нужно его иметь.

```
pip3 install certora-cli-beta
```

`beta` версия нужна для того, чтобы работали фичи для solana.

Добавить в PATH директорию `/path/to/Python/{version}/bin`, если ее там нет, для удобства.

Также стоит скачать `solana tool suite`. Это можно пропустить, если вы не хотите тестировать контракты в локальном блокчейне, а только с помощью `solana-cvt`.

```
sh -c "$(curl -sSfL https://release.solana.com/v1.17.13/install)"
```

Также нужно получить ключ [тут](https://www.certora.com/signup).

И добавить его в env

```
export CERTORAKEY={ключ, который пришел на почту}
```

### Подготовка solana-cvt

Нужно склонировать репозиторий, потому что `solana-cvt` не добавлена в crates.io

```
git clone https://github.com/Certora/solana-cvt/ 
```

## Уязвимые контракты

Находятся в папке [contracts](./contracts).

## Использование Certora Prover

### Написание спек (тестов)

В `Cargo.toml` нужно добавить зависимость

```
[dependencies.cvt]
path = "relative/path/to/solana-cvt"
```

Обратите внимание, что модуль называется cvt, а не `solana-cvt`, как в статье.

В `lib.rs` добавляем новый модуль `mod certora;`, создаем файл `certora.rs`.

Теперь можно приступать к написанию тестов.

Один тест - одна функция в этом модуле без аргументов. Чтобы rust-analyzer не ругался на неиспользуемость функций, стоит добавить аннотацию `#[no_mangle]`.

Также убедитесь, что версия `solana-program` совпадает с той, которая указана в скаченном `solana-cvt`, иначе могут быть конфликты типов.

### Cvt API

- Создать pubkey - `cvt::CVT_nondet_pubkey()`
- Создать аккаунт - `cvt::nondet::<AccountInfo>()`
- Создать числовое значение `cvt::nondet::<u64>()` - вместо u64 можно использовать поддерживаемый solana тип.
- Ограничить недетерминированное значение - `cvt::CVT_assume(predicate(nondet_val))` - например, чтобы сказать SMT солверу, что u64 значение ограничено, можно написать `cvt::CVT_assume(amount > 0 && amount < 10)`
- Ассерт - `cvt::CVT_assert(wallet_after.balance == amount)`

В целом этих базовых вещей уже достаточно для очень комплексных проверок.

### Деплой тестирования

Первое, что нужно сделать, проверить, что в `Cargo.toml` написано следующее

```
[lib]
crate-type = ["cdylib", "lib"]
```

иначе, при компиляции не появится `.so` файл. Далее пробуем собрать контракт

```
cargo build-sbf --arch=sbfv2
```

Если компилятор отработал без ошибок, то это значит, что могли остаться только логические ошибки или ошибки специфичные для блокчейнов, overflow, underflow и тд. Должен был появиться файл `./target/sbf-solana-solana/release/{имя cargo проекта}.so`.

Далее можно отправлять запрос на проведение анализа.

```
certoraRun target/sbf-solana-solana/release/{имя cargo проекта}.so
```

В консоли отобразится ссылка, по которой можно будет посмотреть результаты анализа.

## Выводы

`solana-cvt` пока еще довольно сырая технология, которую трудно использовать в проде, возможно что-то изменится со временем, но пока не рекомендую. Лучше просто написать качественные тесты, которые будут гарантированно работать и не в облаке, а локально.

## Автор

Попов Степан.
